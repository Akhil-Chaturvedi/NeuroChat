import json
import uuid
from datetime import datetime
from memory.memory_store import save_to_memory
from chat.chat_manager import create_chat_session, generate_chat_id # Ensure generate_chat_id is here or moved
import hashlib
import os
import shutil
import re # For regex parsing of asset pointers

def get_unique_filename(directory, filename):
    """Generates a unique filename if one already exists in the directory."""
    name, ext = os.path.splitext(filename)
    counter = 1
    new_filename = filename
    while os.path.exists(os.path.join(directory, new_filename)):
        new_filename = f"{name}_{counter}{ext}"
        counter += 1
    return new_filename

def import_chatgpt_json(json_contents: str, extracted_files_base_path: str, task_id=None, task_statuses=None):
    try:
        # This function now expects the content of a single chat JSON file (a dictionary)
        data = json.loads(json_contents)
    except json.JSONDecodeError as e:
        return {"error": f"Invalid JSON file: {str(e)}"}

    # Ensure the top-level object is a dictionary for a single conversation
    if not isinstance(data, dict):
        return {"error": "Invalid conversation JSON structure. Expected a dictionary at the root."}
    
    convo = data # 'data' is already the single conversation dictionary
    title = convo.get("title") or "Untitled Chat"
    mapping = convo.get("mapping", {})
    
    timestamp = convo.get("create_time")
    if timestamp is None:
        timestamp = convo.get("update_time") or datetime.now().timestamp()
    
    # Use the shared generate_chat_id function for consistency
    chat_id = generate_chat_id(title, timestamp) 

    processed_messages_data = []
    for item_id, item in mapping.items():
        if not isinstance(item, dict):
            continue

        msg = item.get("message")
        
        if not isinstance(msg, dict):
            continue

        # MODIFIED: Extract the timestamp for EACH message
        message_create_time = msg.get("create_time")

        role = msg.get("author", {}).get("role")
        content_obj = msg.get("content", {})
        content_parts = content_obj.get("parts", [])

        if role in ("user", "assistant") and content_parts:
            message_data = {
                "role": role,
                "content_type": "text",
                "text": "",
                "media_url": None,
                "timestamp": message_create_time, # Store the message's timestamp
            }

            first_part = content_parts[0]
            if isinstance(first_part, str):
                message_data["text"] = first_part
            elif isinstance(first_part, dict):
                if first_part.get("content_type") == "image_asset_pointer":
                    asset_pointer = first_part.get("asset_pointer")
                    if asset_pointer:
                        match = re.search(r"file-service://([\w-]+)", asset_pointer)
                        if match:
                            asset_uuid = match.group(1)
                            
                            image_found = False
                            # Broad search for the image file
                            for root_dir, _, files in os.walk(extracted_files_base_path):
                                for fname in files:
                                    if (asset_uuid in fname) and \
                                       fname.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg')):
                                        original_image_path = os.path.join(root_dir, fname)
                                        
                                        chat_media_dir = os.path.join("storage", "media", chat_id)
                                        os.makedirs(chat_media_dir, exist_ok=True)
                                        
                                        unique_image_filename = get_unique_filename(chat_media_dir, fname)
                                        destination_path = os.path.join(chat_media_dir, unique_image_filename)
                                        
                                        shutil.copy(original_image_path, destination_path)
                                        
                                        message_data["content_type"] = "image"
                                        message_data["media_url"] = f"/media/{chat_id}/{unique_image_filename}"
                                        message_data["text"] = msg.get("content", {}).get("text", "") or f"Image generated by {role}."
                                        image_found = True
                                        break
                                if image_found:
                                    break
                            if not image_found:
                                message_data["text"] = f"Image asset (UUID: {asset_uuid}) could not be located."
                        else:
                            message_data["text"] = "Invalid image asset pointer format."
                    else:
                        message_data["text"] = "Image asset pointer is missing."

                elif first_part.get("content_type") == "code":
                    message_data["content_type"] = "code"
                    message_data["text"] = first_part.get("text", "")
                else:
                    try:
                        message_data["text"] = json.dumps(first_part, ensure_ascii=False)
                    except TypeError:
                        message_data["text"] = str(first_part)
            else:
                message_data["text"] = str(first_part)
            
            processed_messages_data.append(message_data)
    
    if not processed_messages_data:
        create_chat_session(chat_id, title, timestamp)
        return {
            "title": title,
            "messages_count": 0,
            "chat_id": chat_id,
            "message": "No processable messages found in this chat, but session created."
        }

    # Create the chat session and save messages
    create_chat_session(chat_id, title, timestamp)
    for msg_data in processed_messages_data:
        # MODIFIED: Pass the message's specific timestamp to save_to_memory
        save_to_memory(
            text=msg_data["text"],
            chat_id=chat_id,
            role=msg_data["role"],
            content_type=msg_data["content_type"],
            media_url=msg_data["media_url"],
            message_timestamp=msg_data["timestamp"] # Pass the correct timestamp here
        )
    total_messages = len(processed_messages_data)

    return {
        "title": title,
        "messages_count": total_messages,
        "chat_id": chat_id,
        "message": f"Imported chat '{title}' with {total_messages} messages."
    }