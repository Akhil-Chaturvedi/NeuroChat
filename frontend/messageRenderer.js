// A self-contained module for rendering chat messages.
// It doesn't know about chat IDs or API calls; it just builds HTML from data.

/**
 * Escapes HTML special characters to prevent XSS attacks.
 * @param {string} str The string to escape.
 * @returns {string} The escaped string.
 */
function escapeHTML(str) {
    if (!str) return '';
    return str.replace(/[&<>"']/g, match => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
    }[match]));
}

/**
 * Renders citation links for an AI message.
 * @param {Array<Object>} citations Array of citation objects.
 * @returns {string} HTML string for the citations container.
 */
function renderCitations(citations) {
    if (!citations || citations.length === 0) return '';
    const citationLinks = citations.map((citation, index) =>
        `<a href="${escapeHTML(citation.source_url)}" target="_blank" class="citation-link" title="${escapeHTML(citation.source_title)}">[${index + 1}]</a>`
    ).join(' ');
    return `<div class="citations-container">Sources: ${citationLinks}</div>`;
}

/**
 * Renders the model information footer for an AI message.
 * @param {string} modelSlug The model ID string.
 * @returns {string} HTML string for the model info.
 */
function renderModelInfo(modelSlug) {
    if (!modelSlug) return '';
    const modelName = modelSlug.split('/').pop();
    return `<div class="model-info">Model: ${escapeHTML(modelName)}</div>`;
}

// ### NEW HELPER FUNCTION (Restored from your old code) ###
/**
 * Creates the HTML for the custom instructions bubble.
 * @param {string} instructions The custom instructions text.
 * @returns {string} HTML string for the instructions bubble.
 */
function renderCustomInstructions(instructions) {
    if (!instructions) return '';
    return `<div class="custom-instructions-bubble">
                <div class="custom-instructions-header">Custom Instructions Applied</div>
                <div class="custom-instructions-content">${escapeHTML(instructions)}</div>
            </div>`;
}

/**
 * Takes HTML content and citation data, finds placeholders like [CITATION:6],
 * and replaces them with proper, clickable <a> tags.
 * @param {string} htmlContent The HTML string generated by the Markdown parser.
 * @param {Array<Object>} citations The array of citation data for the message.
 * @returns {string} The final HTML with citation links.
 */
function replaceCitationPlaceholders(htmlContent, citations) {
    if (!citations || citations.length === 0) {
        return htmlContent;
    }

    // Create a quick-lookup map from citation index to its data
    const citationMap = new Map();
    citations.forEach(c => {
        const meta = c.metadata || {};
        const extra = meta.extra || {};
        if (extra.cited_message_idx !== undefined && meta.url) {
            citationMap.set(extra.cited_message_idx, {
                url: meta.url,
                title: meta.title || 'Source'
            });
        }
    });

    if (citationMap.size === 0) {
        return htmlContent;
    }

    const displayNumMap = new Map();
    let currentDisplayNum = 1;

    // Find and replace all [CITATION:...] placeholders
    return htmlContent.replace(/\[CITATION:(\d+)\]/g, (match, citationIndexStr) => {
        const citationIndex = parseInt(citationIndexStr, 10);
        const citationData = citationMap.get(citationIndex);

        if (!displayNumMap.has(citationIndex)) {
            displayNumMap.set(citationIndex, currentDisplayNum++);
        }
        const displayNum = displayNumMap.get(citationIndex);

        if (citationData) {
            const safeTitle = escapeHTML(citationData.title);
            return `<a href="${escapeHTML(citationData.url)}" title="${safeTitle}" target="_blank" class="citation-link">[${displayNum}]</a>`;
        }
        // If for some reason we have a placeholder but no data, just show the number
        return `[${displayNum}]`;
    });
}


/**
 * The main exported function. It takes message data and renders it into the message area.
 * @param {Object} messageData The message object from the backend or local state.
 * @param {HTMLElement} messageArea The DOM element to append the message to.
 */
export function renderMessage(messageData, messageArea) {
    if (!messageArea) return;

    // --- [THIS IS THE FIX] ---
    // At the very beginning of rendering a message, check if it has custom instructions attached.
    // If it does, render the bubble first. This bubble will appear right before the
    // first message of a chat that uses them.
    if (messageData.custom_instructions) {
        messageArea.insertAdjacentHTML('beforeend', renderCustomInstructions(messageData.custom_instructions));
    }
    // --- [END OF FIX] ---

    // The rest of the function continues exactly as it was before
    if (messageData.is_hidden || (!messageData.text && !messageData.media_url && !messageData.details && !messageData.is_merged_message)) {
        return;
    }

    const { role, text, content_type, media_url, model_slug, citations, details, is_merged_message, content_parts } = messageData;
    const messageWrapper = document.createElement('div');
    messageWrapper.className = 'message-wrapper';

    const messageDiv = document.createElement('div');
    const messageClass = role === 'assistant' ? 'ai-message' : 'user-message';
    messageDiv.className = `message ${messageClass}`;

    if (is_merged_message && content_parts) {
        content_parts.forEach(part => {
            if (part.type === 'text' && part.content) {
                const p = document.createElement('div');
                let html = marked.parse(part.content, { gfm: true, breaks: true });
                p.innerHTML = replaceCitationPlaceholders(html, citations);
                messageDiv.appendChild(p);
            } else if (part.type === 'details') {
                const detailElement = document.createElement('details');
                detailElement.className = 'collapsible-section';
                const safeContent = escapeHTML(part.content).replace(/\n/g, '<br>');
                detailElement.innerHTML = `<summary>${escapeHTML(part.title)}</summary><div class="collapsible-content">${safeContent}</div>`;
                messageDiv.appendChild(detailElement);
            }
        });
    } else {
        let contentHTML = '';
        if (text) {
            let html = marked.parse(text, { gfm: true, breaks: true });
            contentHTML = replaceCitationPlaceholders(html, citations);
        }
        if (content_type === 'image' && media_url) {
            contentHTML = `<img src="${escapeHTML(media_url)}" alt="Uploaded Image" class="message-image"><p>${contentHTML}</p>`;
        } else if (content_type === 'code') {
            contentHTML = `<pre><code>${escapeHTML(text)}</code></pre>`;
        }
        
        messageDiv.innerHTML = contentHTML;

        if (details && Array.isArray(details)) {
            details.forEach(detail => {
                const detailElement = document.createElement('details');
                detailElement.className = 'collapsible-section';
                const safeContent = escapeHTML(detail.content).replace(/\n/g, '<br>');
                detailElement.innerHTML = `<summary>${escapeHTML(detail.title)}</summary><div class="collapsible-content">${safeContent}</div>`;
                messageDiv.appendChild(detailElement);
            });
        }
    }

    if (role === 'assistant') {
        const footer = document.createElement('div');
        footer.className = 'message-footer';
        let footerHTML = '';
        if (model_slug) footerHTML += renderModelInfo(model_slug);
        if (footerHTML) {
            footer.innerHTML = footerHTML;
            messageDiv.appendChild(footer);
        }
    }

    messageWrapper.appendChild(messageDiv);
    messageArea.appendChild(messageWrapper);
}